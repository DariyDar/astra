---
phase: 01-infrastructure-and-security-foundation
plan: 02
type: execute
wave: 2
depends_on:
  - 01-01
files_modified:
  - src/crypto/encrypt.ts
  - src/crypto/types.ts
  - src/db/repositories/credentials.ts
  - src/logging/logger.ts
  - src/logging/correlation.ts
  - src/logging/audit.ts
  - src/llm/client.ts
  - src/llm/types.ts
  - src/health/checker.ts
  - src/health/alerter.ts
  - src/bot/index.ts
  - src/worker/index.ts
autonomous: true
requirements:
  - INFRA-02
  - INFRA-03
  - INFRA-04
  - INFRA-05

must_haves:
  truths:
    - "API tokens can be encrypted and stored in PostgreSQL, then decrypted back to original value"
    - "Encrypted tokens in the database cannot be read as plaintext"
    - "Every bot action produces a structured JSON log entry with a correlation ID"
    - "Audit trail entries are written to PostgreSQL for each action"
    - "Audit entries older than 30 days are automatically deleted by the cleanup job"
    - "LLM requests go to Claude Sonnet and responses are logged with token usage"
    - "When Claude API is unavailable (529/503/429), the user receives a friendly Telegram message"
    - "Health checks run periodically and alert via Telegram when services are unhealthy"
  artifacts:
    - path: "src/crypto/encrypt.ts"
      provides: "AES-256-GCM encrypt/decrypt functions"
      exports: ["encrypt", "decrypt"]
    - path: "src/db/repositories/credentials.ts"
      provides: "Encrypted credential storage and retrieval"
      exports: ["CredentialRepository"]
    - path: "src/logging/logger.ts"
      provides: "Pino logger factory with redaction"
      exports: ["logger"]
    - path: "src/logging/correlation.ts"
      provides: "Correlation ID generation and propagation"
      exports: ["createRequestLogger"]
    - path: "src/logging/audit.ts"
      provides: "Audit trail writer to PostgreSQL"
      exports: ["writeAuditEntry"]
    - path: "src/llm/client.ts"
      provides: "Claude API wrapper with error handling and alerting"
      exports: ["callClaude"]
    - path: "src/health/checker.ts"
      provides: "Service health check logic"
      exports: ["HealthChecker"]
    - path: "src/health/alerter.ts"
      provides: "Telegram alert sender for health issues"
      exports: ["sendHealthAlert"]
  key_links:
    - from: "src/crypto/encrypt.ts"
      to: "src/db/repositories/credentials.ts"
      via: "encrypt/decrypt used for credential storage"
      pattern: "import.*encrypt"
    - from: "src/logging/audit.ts"
      to: "src/db/schema.ts"
      via: "writes to audit_trail table"
      pattern: "auditTrail"
    - from: "src/llm/client.ts"
      to: "src/health/alerter.ts"
      via: "triggers alert on API errors"
      pattern: "sendHealthAlert|alertUser"
    - from: "src/bot/index.ts"
      to: "src/logging/correlation.ts"
      via: "creates request logger per incoming message"
      pattern: "createRequestLogger"
    - from: "src/worker/index.ts"
      to: "src/logging/audit.ts"
      via: "runs audit trail cleanup job"
      pattern: "audit.*cleanup|deleteOld"
---

<objective>
Build the application service layer: credential encryption, structured logging with audit trail, Claude API client, and health monitoring with Telegram alerts.

Purpose: Transform the skeleton from Plan 01 into a fully operational infrastructure layer that encrypts credentials, logs all actions, talks to Claude, and alerts the user when things break. This is the invisible foundation every future feature depends on.
Output: Working encryption service, Pino logging with correlation IDs, PostgreSQL audit trail with 30-day cleanup, Claude API wrapper with error handling, and health checker with Telegram alerts.
</objective>

<execution_context>
@C:/Users/dimsh/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/dimsh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-infrastructure-and-security-foundation/01-RESEARCH.md
@.planning/phases/01-infrastructure-and-security-foundation/01-CONTEXT.md
@.planning/phases/01-infrastructure-and-security-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement credential encryption service and structured logging infrastructure</name>
  <files>
    src/crypto/encrypt.ts
    src/crypto/types.ts
    src/db/repositories/credentials.ts
    src/logging/logger.ts
    src/logging/correlation.ts
    src/logging/audit.ts
  </files>
  <action>
**Encryption Service (INFRA-02):**

1. Create src/crypto/types.ts:
   - Export `EncryptedPayload` interface: { ciphertext: string, iv: string, tag: string } (all base64-encoded)

2. Create src/crypto/encrypt.ts:
   - Use Node.js built-in `crypto` module (NOT a third-party library)
   - Algorithm: 'aes-256-gcm'
   - IV_LENGTH = 12 (96-bit, NIST recommended for GCM)
   - TAG_LENGTH = 16 (128-bit auth tag)
   - `encrypt(plaintext: string, key: Buffer): EncryptedPayload`
     - Generate fresh random IV via `crypto.randomBytes(IV_LENGTH)` for EVERY call (CRITICAL: never reuse IVs)
     - Create cipher with createCipheriv
     - Return { ciphertext (base64), iv (base64), tag (base64) }
   - `decrypt(payload: EncryptedPayload, key: Buffer): string`
     - Create decipher with createDecipheriv
     - MUST call `decipher.setAuthTag()` BEFORE `decipher.final()` (CRITICAL: without this, GCM provides no integrity)
     - Return plaintext string
   - `deriveKeyFromHex(hexKey: string): Buffer` - convert 64-char hex string to 32-byte Buffer

3. Create src/db/repositories/credentials.ts:
   - `CredentialRepository` class
   - Constructor takes `encryptionKey: Buffer`
   - `store(name: string, value: string): Promise<void>` - encrypts value, upserts into credentials table (onConflictDoUpdate on name)
   - `retrieve(name: string): Promise<string | null>` - reads from DB, decrypts, returns plaintext or null
   - `delete(name: string): Promise<void>` - removes credential by name
   - `list(): Promise<string[]>` - returns list of credential names (NOT values)
   - Uses Drizzle ORM with the schema from Plan 01

**Logging Infrastructure (INFRA-03):**

4. Create src/logging/logger.ts:
   - Create base Pino logger instance
   - Configure: level from env.LOG_LEVEL, isoTime timestamps
   - Custom formatter: level as string label (not number)
   - Redact sensitive fields: ['*.token', '*.apiKey', '*.password', '*.secret', '*.encryptionKey', '*.ciphertext']
   - In development (NODE_ENV=development), use pino-pretty transport for human-readable output
   - Export `logger` as the base logger instance

5. Create src/logging/correlation.ts:
   - `createRequestLogger(context: { userId?: string, action?: string, source?: string }): pino.Logger`
   - Generates UUID v4 correlation ID via `crypto.randomUUID()`
   - Returns `logger.child({ correlationId, ...context })`
   - This is the primary way all request-scoped logging happens

6. Create src/logging/audit.ts:
   - `writeAuditEntry(entry: AuditEntry): Promise<void>` where AuditEntry has: correlationId, userId?, action, source?, model?, metadata?, status ('success'|'error'|'timeout'), errorMessage?
   - Inserts into audit_trail table via Drizzle
   - Fire-and-forget pattern: catch and log errors but don't throw (audit failure should not break the request)
   - `queryAuditTrail(correlationId: string): Promise<AuditEntry[]>` - retrieve all entries for a correlation ID
   - `cleanupOldEntries(retentionDays: number): Promise<number>` - delete entries older than N days, return count deleted

CRITICAL ANTI-PATTERNS TO AVOID:
- Do NOT encrypt everything. Only API tokens and OAuth refresh tokens. Per user decision.
- Do NOT log sensitive data. Use Pino's redact config.
- Do NOT make audit writes synchronous/blocking. Fire-and-forget.
  </action>
  <verify>
    <automated>npx tsc --noEmit</automated>
    <automated>npx tsx -e "import { encrypt, decrypt } from './src/crypto/encrypt.ts'; const k = Buffer.from('a'.repeat(64), 'hex'); const enc = encrypt('test', k); const dec = decrypt(enc, k); console.assert(dec === 'test', 'roundtrip failed'); console.log('encrypt/decrypt roundtrip OK');"</automated>
    <manual>Verify encrypt.ts generates fresh IV per call, decrypt.ts calls setAuthTag before final</manual>
  </verify>
  <done>encrypt("hello", key) -> decrypt(payload, key) === "hello" for any input. CredentialRepository stores and retrieves encrypted values. Logger produces JSON with correlation IDs and redacts sensitive fields. Audit writer inserts entries into PostgreSQL and cleanup deletes entries older than 30 days.</done>
</task>

<task type="auto">
  <name>Task 2: Implement LLM client and health monitoring, wire bot and worker</name>
  <files>
    src/llm/client.ts
    src/llm/types.ts
    src/health/checker.ts
    src/health/alerter.ts
    src/bot/index.ts
    src/worker/index.ts
  </files>
  <action>
**LLM Client (INFRA-04 -- user override: single model Sonnet, no tiering):**

1. Create src/llm/types.ts:
   - Export types for LLM request/response logging
   - `LlmRequestContext`: { correlationId, action, userId? }

2. Create src/llm/client.ts:
   - Import `@anthropic-ai/sdk`
   - Create Anthropic client with ANTHROPIC_API_KEY from env config
   - `callClaude(messages: Anthropic.MessageParam[], options?: { maxTokens?: number, system?: string }, requestLogger?: pino.Logger): Promise<Anthropic.Message>`
   - Model: HARDCODE 'claude-sonnet-4-20250514' (per user decision: single model for all tasks, NO tiering, NO classification)
   - Default maxTokens: 4096
   - On success: log event 'llm_response' with model, inputTokens, outputTokens, stopReason via the request logger
   - Write audit entry with action 'llm_request', model, token counts in metadata
   - On error: catch `Anthropic.APIError`
     - For 529 (overloaded), 503 (service unavailable): send Telegram alert to user with friendly message "Claude is temporarily unavailable. I'll keep trying and let you know when it's back." (per user decision: inform user, no silent retries, no alternative providers)
     - For 429 (rate limit): log warning, DO NOT alert user (rate limits are transient)
     - For 401 (auth): log CRITICAL error, alert user "API key issue detected"
     - Re-throw the error after handling
   - Do NOT implement: multi-model routing, task classification, fallback chains, silent retries (all deferred per user decision)

**Health Monitoring (INFRA-05 -- user override: inform user, no silent fallback):**

3. Create src/health/alerter.ts:
   - `sendHealthAlert(message: string): Promise<void>`
   - Uses grammY Bot.api.sendMessage to TELEGRAM_ADMIN_CHAT_ID
   - Creates a standalone Bot API instance (not the main bot, just for sending alerts)
   - Catches send errors and logs them (alert failure should not cascade)
   - Rate-limit alerts: track last alert time per service, don't send more than 1 alert per service per 5 minutes

4. Create src/health/checker.ts:
   - `HealthChecker` class
   - `checkAll(): Promise<HealthResult[]>` where HealthResult = { service: string, healthy: boolean, latencyMs: number, error?: string }
   - Check PostgreSQL: run `SELECT 1` query
   - Check Redis: run `PING` command
   - Check Qdrant: HTTP GET to `http://qdrant:6333/readyz`
   - Check Claude: call Anthropic API `models.retrieve('claude-sonnet-4-20250514')` (lightweight model info request, not a completion)
   - Use Promise.allSettled for parallel checks
   - If any service unhealthy: call sendHealthAlert with list of unhealthy services
   - `startPeriodicChecks(intervalMs: number): void` - run checkAll on interval (default: 60000ms = 1 minute)
   - `stopPeriodicChecks(): void` - clear interval

**Wire Everything Into Bot and Worker:**

5. Update src/bot/index.ts:
   - Add grammY middleware that creates a request logger (correlation ID) for every incoming message
   - Add error handler middleware that logs errors with correlation ID and writes audit entry
   - Add middleware that writes audit entry for every handled message (action: 'message_received', source: 'telegram')
   - Keep /start command handler
   - Add /health command: runs HealthChecker.checkAll() and replies with formatted status
   - Start health checker periodic checks on bot startup
   - Graceful shutdown: stop health checker, close DB connection

6. Update src/worker/index.ts:
   - Import audit cleanup function
   - Schedule audit trail cleanup via node-cron: run daily at 3 AM, delete entries > 30 days
   - Log cleanup results (how many entries deleted)
   - Graceful shutdown: stop cron jobs, close DB connection

IMPORTANT PER USER DECISIONS:
- Single model (Sonnet) for ALL tasks. No tiering, no classification by complexity.
- When Claude unavailable: inform user via Telegram with friendly message. No silent retries. No alternative providers.
- Health alerts go to Telegram (the bot IS the monitoring channel per user decision).
  </action>
  <verify>
    <automated>npx tsc --noEmit</automated>
    <automated>npx tsx -e "import { HealthChecker } from './src/health/checker.ts'; console.log('HealthChecker type:', typeof HealthChecker); console.assert(typeof HealthChecker === 'function', 'HealthChecker class missing'); console.log('health module loads OK');"</automated>
    <manual>Check that llm/client.ts hardcodes Sonnet model and calls sendHealthAlert on 529/503 errors</manual>
  </verify>
  <done>LLM client sends requests to Claude Sonnet and logs token usage. API errors (529/503) trigger Telegram alerts to user. Health checker monitors all services and alerts on failures. Bot has correlation ID middleware on every message. Worker runs audit cleanup on daily schedule. All wired together and TypeScript compiles clean.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` -- TypeScript compiles without errors
2. encrypt/decrypt roundtrip test: encrypt a string and decrypt it back, values match
3. Credential store/retrieve: store "test-token" encrypted, retrieve it, matches original
4. Logger output is JSON with correlationId field present
5. Audit trail: write entry, query by correlationId, entry found
6. LLM client: call Claude, response logged with token counts
7. Health checker: run checkAll, all services return healthy
8. Bot /health command returns formatted status
9. Worker audit cleanup: verify entries older than 30 days are deleted
</verification>

<success_criteria>
- Encryption roundtrip works: encrypt(value) -> store in DB -> retrieve -> decrypt === original value
- Database contains encrypted ciphertext (not plaintext) for stored credentials
- Every bot interaction produces structured JSON log with correlation ID
- Audit trail table receives entries for each action
- Claude API calls succeed and log model + token usage
- When Claude is unavailable, user gets a Telegram message (not a crash)
- Health checks run every 60 seconds and alert via Telegram on failures
- Worker runs audit cleanup daily, removing entries > 30 days old
</success_criteria>

<output>
After completion, create `.planning/phases/01-infrastructure-and-security-foundation/01-02-SUMMARY.md`
</output>
