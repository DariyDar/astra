---
phase: 01-infrastructure-and-security-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - tsconfig.json
  - .gitignore
  - .env.example
  - drizzle.config.ts
  - docker-compose.yml
  - Dockerfile
  - .dockerignore
  - src/config/env.ts
  - src/db/schema.ts
  - src/db/index.ts
  - src/bot/index.ts
  - src/worker/index.ts
autonomous: true
requirements:
  - INFRA-01

must_haves:
  truths:
    - "Bot container starts and responds to /start command"
    - "Database is ready to store encrypted credentials"
    - "All infrastructure services (PostgreSQL, Redis, Qdrant) pass health checks before app services start"
    - "docker compose up starts PostgreSQL, Redis, Qdrant, bot, and worker containers"
    - "Bot and worker processes start successfully after infrastructure is healthy"
  artifacts:
    - path: "docker-compose.yml"
      provides: "All service definitions with health checks"
      contains: "service_healthy"
    - path: "Dockerfile"
      provides: "Node.js app container build with multi-stage"
      contains: "node:22"
    - path: "src/config/env.ts"
      provides: "Zod-validated environment configuration"
      contains: "z.object"
    - path: "src/db/schema.ts"
      provides: "Drizzle schema with credentials and audit_trail tables"
      contains: "pgTable"
    - path: "src/db/index.ts"
      provides: "Database connection instance"
      contains: "drizzle"
    - path: "src/bot/index.ts"
      provides: "Telegram bot entry point"
      contains: "Bot"
    - path: "src/worker/index.ts"
      provides: "Worker process entry point"
  key_links:
    - from: "docker-compose.yml"
      to: "Dockerfile"
      via: "build context"
      pattern: "build:\\s*\\."
    - from: "docker-compose.yml"
      to: "postgres service"
      via: "depends_on with service_healthy"
      pattern: "condition:\\s*service_healthy"
    - from: "src/db/index.ts"
      to: "src/db/schema.ts"
      via: "schema import"
      pattern: "import.*schema"
    - from: "src/config/env.ts"
      to: ".env"
      via: "dotenv loading and Zod validation"
      pattern: "envSchema\\.parse"
---

<objective>
Initialize the Astra project with TypeScript, Docker Compose stack, database schema, and minimal bot/worker entry points.

Purpose: Create the foundational project structure that all subsequent plans and phases build upon. Without this, nothing else can run.
Output: Working Docker Compose stack that starts all 5 services (PostgreSQL, Redis, Qdrant, bot, worker) with health checks, plus the TypeScript project skeleton with Drizzle schema.
</objective>

<execution_context>
@C:/Users/dimsh/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/dimsh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-infrastructure-and-security-foundation/01-RESEARCH.md
@.planning/phases/01-infrastructure-and-security-foundation/01-CONTEXT.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize npm project, TypeScript config, and environment scaffolding</name>
  <files>
    package.json
    tsconfig.json
    .gitignore
    .env.example
    drizzle.config.ts
  </files>
  <action>
Initialize a Node.js TypeScript project:

1. `npm init -y` then update package.json:
   - name: "astra"
   - type: "module" (ESM)
   - scripts: "dev:bot": "tsx src/bot/index.ts", "dev:worker": "tsx src/worker/index.ts", "build": "tsc", "db:generate": "drizzle-kit generate", "db:migrate": "drizzle-kit migrate"

2. Install dependencies (exact versions from research):
   ```
   npm install @anthropic-ai/sdk grammy pino ioredis @qdrant/js-client-rest pg zod uuid dotenv node-cron drizzle-orm
   npm install -D typescript @types/node tsx pino-pretty @types/pg @types/uuid drizzle-kit @types/node-cron
   ```

3. Create tsconfig.json:
   - target: "ES2022", module: "NodeNext", moduleResolution: "NodeNext"
   - outDir: "dist", rootDir: "src", strict: true
   - esModuleInterop: true, skipLibCheck: true

4. Create .gitignore: node_modules, dist, .env, *.js.map, .planning/codebase

5. Create .env.example with ALL required vars (documented, no real values):
   - DATABASE_URL=postgresql://astra:astra_dev@postgres:5432/astra
   - REDIS_URL=redis://redis:6379
   - ENCRYPTION_KEY=(64 hex chars - generate with: node -e "console.log(require('crypto').randomBytes(32).toString('hex'))")
   - TELEGRAM_BOT_TOKEN=(from @BotFather on Telegram)
   - TELEGRAM_ADMIN_CHAT_ID=(your Telegram user ID - send /start to @userinfobot to get it)
   - ANTHROPIC_API_KEY=sk-ant-xxx (get from https://console.anthropic.com/settings/keys â€” usage-based billing, see https://console.anthropic.com/settings/plans)
   - LOG_LEVEL=info
   - NODE_ENV=development
   - POSTGRES_USER=astra
   - POSTGRES_PASSWORD=astra_dev
   - POSTGRES_DB=astra

6. Create drizzle.config.ts pointing to src/db/schema.ts, PostgreSQL driver, DATABASE_URL from env.
  </action>
  <verify>
    <automated>npx tsc --noEmit</automated>
    <manual>Check .gitignore excludes .env, .env.example has all 10 vars documented</manual>
  </verify>
  <done>package.json has all dependencies and scripts, tsconfig.json targets ES2022 with NodeNext modules, .gitignore excludes .env and node_modules, .env.example documents all required variables including Anthropic API key setup URL, drizzle.config.ts points to schema</done>
</task>

<task type="auto">
  <name>Task 2: Create Docker Compose stack with all 5 services</name>
  <files>
    docker-compose.yml
    Dockerfile
    .dockerignore
  </files>
  <action>
1. Create docker-compose.yml with ALL 5 services per user decision:
   - **postgres**: postgres:16-alpine, healthcheck with pg_isready, volume for data, POSTGRES_USER/DB/PASSWORD from env, port 5432 Docker-internal only
   - **redis**: redis:7-alpine, healthcheck with redis-cli ping, port 6379 Docker-internal only
   - **qdrant**: qdrant/qdrant:latest, healthcheck with curl to /readyz, volume for storage, port 6333 Docker-internal only
   - **bot**: build from Dockerfile, depends_on postgres/redis/qdrant all with condition: service_healthy, restart: unless-stopped, env_file: .env, port not exposed (Telegram uses long polling, no inbound needed)
   - **worker**: build from Dockerfile, command override to run worker entry point, same depends_on as bot, restart: unless-stopped, env_file: .env
   - Named volumes: postgres_data, qdrant_data
   - Network: default bridge (all services on same network, internal communication by service name)

2. Create Dockerfile:
   - Multi-stage build: base (node:22-alpine), deps (npm ci), build (tsc), production (copy dist + node_modules)
   - Default CMD: ["node", "dist/bot/index.js"]

3. Create .dockerignore: node_modules, dist, .env, .git, .planning

IMPORTANT: No LiteLLM service (per user decision). Qdrant runs idle in Phase 1 (actual indexing in Phase 4) but must be healthy.
  </action>
  <verify>
    <automated>npx tsc --noEmit</automated>
    <automated>docker compose config --quiet</automated>
    <manual>Verify Dockerfile uses multi-stage build, .dockerignore excludes .git</manual>
  </verify>
  <done>docker-compose.yml defines all 5 services (postgres, redis, qdrant, bot, worker) with health checks and depends_on conditions, Dockerfile uses multi-stage build (base/deps/build/production), .dockerignore excludes .git and .env and node_modules</done>
</task>

<task type="auto">
  <name>Task 3: Create database schema and config validation with bot/worker entry points</name>
  <files>
    src/config/env.ts
    src/db/schema.ts
    src/db/index.ts
    src/bot/index.ts
    src/worker/index.ts
  </files>
  <action>
1. Create src/config/env.ts:
   - Import zod and dotenv/config
   - Define envSchema with Zod:
     - DATABASE_URL: z.string().url()
     - REDIS_URL: z.string().url()
     - ENCRYPTION_KEY: z.string().length(64, 'Must be 32 bytes hex-encoded')
     - TELEGRAM_BOT_TOKEN: z.string().min(1)
     - TELEGRAM_ADMIN_CHAT_ID: z.string().min(1)
     - ANTHROPIC_API_KEY: z.string().startsWith('sk-ant-')
     - LOG_LEVEL: z.enum(['fatal','error','warn','info','debug','trace']).default('info')
     - NODE_ENV: z.enum(['development','production']).default('development')
   - Export parsed env and type
   - Use Pino redact paths for sensitive fields: ['*.token', '*.apiKey', '*.password', '*.secret', '*.encryptionKey']

2. Create src/db/schema.ts with Drizzle pgTable definitions:
   - **credentials** table: id (serial PK), name (text, unique, not null), ciphertext (text, not null), iv (text, not null), tag (text, not null), createdAt (timestamp with TZ, default now), updatedAt (timestamp with TZ, default now)
   - **audit_trail** table: id (bigserial PK), correlationId (text, not null), userId (text), action (text, not null), source (text), model (text), metadata (jsonb), status (text, not null), errorMessage (text), createdAt (timestamp with TZ, default now, not null)
   - Add index on audit_trail.createdAt for cleanup queries
   - Add index on audit_trail.correlationId for lookup queries

3. Create src/db/index.ts:
   - Import drizzle from drizzle-orm/node-postgres
   - Import pg Pool
   - Create pool from DATABASE_URL
   - Export drizzle instance with schema
   - Export a close function for graceful shutdown

4. Create src/bot/index.ts (minimal shell):
   - Import grammY Bot
   - Import env config
   - Create Bot instance with TELEGRAM_BOT_TOKEN
   - Add a /start command handler that replies "Astra is running"
   - Add error handler that logs errors
   - Call bot.start() with graceful shutdown on SIGINT/SIGTERM
   - Log "Bot started" on startup

5. Create src/worker/index.ts (minimal shell):
   - Import env config
   - Log "Worker started"
   - Set up graceful shutdown on SIGINT/SIGTERM
   - Add placeholder comment: "// Phase 1: audit trail cleanup job will be added in Plan 02"
   - Keep process alive with setInterval

NOTE: Bot and worker are minimal shells in this task. They prove the Docker services start and connect. Full functionality (logging, encryption, health checks) comes in Plan 02.
  </action>
  <verify>
    <automated>npx tsc --noEmit</automated>
    <manual>Check that src/db/schema.ts exports credentials and audit_trail tables</manual>
  </verify>
  <done>Config validation catches missing/invalid env vars with descriptive errors, DB schema defines credentials (with ciphertext, iv, tag columns) and audit_trail tables with indexes on createdAt and correlationId, bot responds to /start, worker starts and stays alive</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` -- TypeScript compiles without errors
2. `docker compose config --quiet` -- Compose file is valid (exits 0, no output)
3. `docker compose up -d` then `docker compose ps` -- all 5 services show "healthy" or "running"
4. Bot responds to /start command in Telegram (requires valid bot token in .env)
5. Schema defines both credentials and audit_trail tables
</verification>

<success_criteria>
- All 5 Docker Compose services defined with health checks
- PostgreSQL, Redis, Qdrant start and pass health checks
- Bot and worker containers start after infrastructure is healthy
- Bot responds to /start command in Telegram
- Database is ready to store encrypted credentials (schema defines credentials table)
- Environment configuration validates all required variables with Zod
</success_criteria>

<output>
After completion, create `.planning/phases/01-infrastructure-and-security-foundation/01-01-SUMMARY.md`
</output>
