---
phase: 02-bot-shell-and-agent-brain
plan: 05
type: execute
wave: 3
depends_on: [02-03, 02-04]
files_modified:
  - src/notifications/preferences.ts
  - src/notifications/urgency.ts
  - src/notifications/dispatcher.ts
  - src/notifications/digest.ts
  - src/worker/index.ts
  - src/bot/index.ts
autonomous: true
requirements: [MSG-05]

must_haves:
  truths:
    - "User can configure notification preferences via /settings command or natural language"
    - "Notifications are classified into 3 urgency levels: urgent, important, normal"
    - "Urgent notifications are delivered immediately to the configured channel"
    - "Morning digest compiles accumulated non-urgent notifications"
    - "Notification delivery channel is configurable per category (Telegram or Slack)"
  artifacts:
    - path: "src/notifications/preferences.ts"
      provides: "CRUD operations for notification preferences"
      exports: ["NotificationPreferences"]
    - path: "src/notifications/urgency.ts"
      provides: "Urgency classification for notification items"
      exports: ["classifyUrgency", "UrgencyLevel"]
    - path: "src/notifications/dispatcher.ts"
      provides: "Routes notifications to correct channel based on preferences"
      exports: ["NotificationDispatcher"]
    - path: "src/notifications/digest.ts"
      provides: "Digest compilation and scheduled delivery"
      exports: ["DigestScheduler"]
  key_links:
    - from: "src/notifications/dispatcher.ts"
      to: "src/notifications/preferences.ts"
      via: "Reads user preferences to determine delivery channel"
      pattern: "preferences"
    - from: "src/notifications/dispatcher.ts"
      to: "src/channels/types.ts"
      via: "Uses ChannelAdapter.send() for delivery"
      pattern: "adapter\\.send"
    - from: "src/notifications/digest.ts"
      to: "src/notifications/dispatcher.ts"
      via: "Dispatches compiled digest"
      pattern: "dispatcher"
    - from: "src/worker/index.ts"
      to: "src/notifications/digest.ts"
      via: "node-cron schedules digest compilation"
      pattern: "DigestScheduler"
---

<objective>
Build the notification system: preference management, urgency classification, notification dispatcher, and scheduled digest delivery. Wire digest scheduling into the worker process and add /settings command to the bot.

Purpose: MSG-05 requires users to configure notification preferences. The user's locked decisions specify 3 urgency levels (urgent/immediate, important/in digest, normal/on request), configurable delivery channel per type, natural language + /settings configuration, and a morning digest for non-urgent items. This plan delivers the notification infrastructure that future phases (3-6) will use for proactive alerts.

Output: Complete notification subsystem with preferences CRUD, urgency classification, multi-channel dispatcher, and scheduled digest delivery.
</objective>

<execution_context>
@C:/Users/dimsh/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/dimsh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-bot-shell-and-agent-brain/02-RESEARCH.md
@.planning/phases/02-bot-shell-and-agent-brain/02-03-SUMMARY.md
@.planning/phases/02-bot-shell-and-agent-brain/02-04-SUMMARY.md
@src/db/schema.ts
@src/channels/types.ts
@src/worker/index.ts
@src/bot/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement notification preferences, urgency classification, and dispatcher</name>
  <files>src/notifications/preferences.ts, src/notifications/urgency.ts, src/notifications/dispatcher.ts</files>
  <action>
Create `src/notifications/preferences.ts` — CRUD for notification_preferences table:
- Class `NotificationPreferences` with constructor accepting drizzle db instance
- `get(userId: string, category: string): Promise<Preference | null>` — Find preference by userId + category
- `getAll(userId: string): Promise<Preference[]>` — List all preferences for a user
- `set(userId: string, category: string, urgencyLevel: UrgencyLevel, deliveryChannel: 'telegram' | 'slack'): Promise<void>` — Upsert preference (insert or update on conflict). Use Drizzle's `onConflictDoUpdate` on the unique (userId, category) constraint.
- `setEnabled(userId: string, category: string, enabled: boolean): Promise<void>` — Enable/disable a preference
- `delete(userId: string, category: string): Promise<void>` — Remove a preference
- `getDefaults(): Preference[]` — Return default preferences:
  - task_deadline: urgent, telegram
  - email_urgent: urgent, telegram
  - calendar_meeting: important, telegram
  - task_update: normal, telegram
  - email_digest: important, telegram
- `ensureDefaults(userId: string): Promise<void>` — Insert defaults if no preferences exist for the user

Type `Preference` should match the notificationPreferences table shape: `{ id, userId, category, urgencyLevel, deliveryChannel, enabled, createdAt, updatedAt }`.

Create `src/notifications/urgency.ts`:
- Type `UrgencyLevel = 'urgent' | 'important' | 'normal'`
- Interface `NotificationItem`:
  - `category`: string (matches preference category)
  - `title`: string
  - `body`: string
  - `source`: string (e.g., 'clickup', 'gmail', 'calendar', 'slack')
  - `metadata?`: Record<string, unknown>
  - `createdAt`: Date
- Function `classifyUrgency(item: NotificationItem, preferences: Preference[]): UrgencyLevel` — Look up the item's category in preferences. If found and enabled, return the configured urgencyLevel. If not found, default to 'normal'.

Create `src/notifications/dispatcher.ts`:
- Class `NotificationDispatcher`
- Constructor accepts `{ adapters: Map<string, ChannelAdapter>, preferences: NotificationPreferences, defaultChannelId: { telegram: string, slack?: string } }`
- `dispatch(userId: string, item: NotificationItem): Promise<void>`:
  1. Look up preference for (userId, item.category)
  2. Determine delivery channel from preference (or default to 'telegram')
  3. Classify urgency
  4. If urgency is 'urgent': send immediately via adapter.send() to the configured channel's defaultChannelId
  5. If urgency is 'important': store in a pending digest queue (in-memory array or Redis list)
  6. If urgency is 'normal': store for on-demand retrieval only
  7. Log the dispatch decision
- `getPendingDigestItems(userId: string): Promise<NotificationItem[]>` — Return accumulated important items, then clear the queue
- `getPendingOnDemandItems(userId: string): Promise<NotificationItem[]>` — Return accumulated normal items
- Use pino logger for all dispatch logging

Import `notificationPreferences` table from `../db/schema.js`. Import types from `../channels/types.js`. Use `eq`, `and` from `drizzle-orm`. Follow ESM conventions.
  </action>
  <verify>
    <automated>npx tsc --noEmit</automated>
    <manual>Verify NotificationPreferences, classifyUrgency, and NotificationDispatcher are exported with all methods</manual>
  </verify>
  <done>Notification preferences CRUD with defaults and upsert. Urgency classification based on user preferences with 3 levels. Dispatcher routes notifications to correct channel with immediate delivery for urgent and queuing for digest. All compile cleanly.</done>
</task>

<task type="auto">
  <name>Task 2: Implement digest scheduler and wire into bot and worker</name>
  <files>src/notifications/digest.ts, src/worker/index.ts, src/bot/index.ts</files>
  <action>
Create `src/notifications/digest.ts`:
- Class `DigestScheduler`
- Constructor accepts `{ dispatcher: NotificationDispatcher, adapters: Map<string, ChannelAdapter>, defaultUserId: string, defaultChannelId: { telegram: string, slack?: string } }`
- `compileMorningDigest(userId: string): Promise<string>` — Get pending digest items from dispatcher. Format into a structured digest message:
  ```
  Good morning! Here's your digest:

  [Important items]:
  - [category icon] title: body
  - ...

  [Normal items you might want to check]:
  - [category icon] title: body
  - ...

  Total: N items
  ```
  If no items, return "No pending notifications. Have a great day!"
  Use moderate emojis per user decision (checkmarks, warnings, calendar icons).
- `deliverDigest(userId: string): Promise<void>` — Compile digest, then send via the dispatcher's default delivery channel. Use the adapter corresponding to the user's preferred digest delivery channel.
- `getScheduledTime(): string` — Return the cron expression for morning digest (default: `'0 8 * * *'` — 8 AM daily). This can be made configurable later via preferences.

Update `src/worker/index.ts`:
- Import DigestScheduler (the class itself will be instantiated when wiring is available)
- For now, add a placeholder comment and a new cron job structure:
  - Add a cron job at `'0 8 * * *'` that logs "Morning digest job triggered" and calls the digest delivery
  - Since the worker doesn't have direct access to the adapters (they live in the bot process), the digest scheduling in this phase will use a simple approach: the digest cron job stores a "digest_pending" flag in Redis, and the bot process checks this flag periodically
  - ALTERNATIVE simpler approach: Run digest scheduling in the bot process (not the worker) since the bot has access to adapters. Add a node-cron schedule in bot/index.ts that calls digestScheduler.deliverDigest().
- Choose the simpler approach: schedule digest delivery in the bot process.

Update `src/bot/index.ts`:
- Add `/settings` command handler that responds with current notification preferences formatted as a readable list. Include instructions: "You can change preferences by telling me in natural language, e.g., 'set task deadlines to urgent on Slack' or 'disable calendar notifications'."
- Add digest scheduling: After router.start(), create a node-cron job for morning digest (8 AM) that calls digestScheduler.deliverDigest()
- Wire NotificationPreferences and NotificationDispatcher into the bot startup
- Ensure graceful shutdown stops the digest cron job

Import node-cron. Import NotificationPreferences from `../notifications/preferences.js`. Import DigestScheduler from `../notifications/digest.js`. Import NotificationDispatcher from `../notifications/dispatcher.js`.
  </action>
  <verify>
    <automated>npx tsc --noEmit</automated>
    <manual>Verify /settings command is registered; digest cron job scheduled in bot; DigestScheduler exported with compileMorningDigest and deliverDigest</manual>
  </verify>
  <done>Digest scheduler compiles and delivers morning digests. /settings command shows current notification preferences. Digest cron job scheduled in bot process at 8 AM daily. Notification system fully wired into bot lifecycle with graceful shutdown.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- /settings command registered on the bot
- NotificationPreferences provides CRUD with defaults and upsert
- NotificationDispatcher routes to correct channel based on urgency and preferences
- DigestScheduler compiles structured digest messages
- Morning digest cron job scheduled in bot process
- Graceful shutdown stops digest cron job
</verification>

<success_criteria>
- User can run /settings to see notification preferences
- Notification system supports 3 urgency levels: urgent (immediate), important (digest), normal (on-demand)
- Urgent notifications delivered immediately to configured channel
- Morning digest compiles accumulated important items
- Default preferences created for new users
- Delivery channel configurable per notification category (Telegram or Slack)
</success_criteria>

<output>
After completion, create `.planning/phases/02-bot-shell-and-agent-brain/02-05-SUMMARY.md`
</output>
