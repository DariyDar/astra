---
phase: 02-bot-shell-and-agent-brain
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/db/schema.ts
  - src/channels/types.ts
  - src/brain/language.ts
  - src/config/env.ts
autonomous: true
requirements: [MSG-01, MSG-02, MSG-03, MSG-05]

must_haves:
  truths:
    - "Database has tables for storing all messages, notification preferences, and user feedback"
    - "Unified message types exist that abstract Telegram and Slack into a common interface"
    - "Language detection correctly distinguishes Russian from English text"
  artifacts:
    - path: "src/db/schema.ts"
      provides: "Messages, notification_preferences, and user_feedback tables"
      contains: "messages"
    - path: "src/channels/types.ts"
      provides: "InboundMessage, OutboundMessage, ChannelAdapter interfaces"
      exports: ["InboundMessage", "OutboundMessage", "ChannelAdapter"]
    - path: "src/brain/language.ts"
      provides: "Language detection for Russian/English"
      exports: ["detectLanguage"]
  key_links:
    - from: "src/channels/types.ts"
      to: "src/brain/language.ts"
      via: "InboundMessage text field fed to detectLanguage"
      pattern: "detectLanguage"
---

<objective>
Create the foundational data schema and type system for Phase 2. Extend the PostgreSQL schema with messages, notification_preferences, and user_feedback tables. Define unified channel types (InboundMessage, OutboundMessage, ChannelAdapter) that abstract platform differences. Implement Cyrillic-based language detection for Russian/English.

Purpose: Every other plan in this phase depends on these types and tables. The schema supports the three-tier memory model, notification system, and self-learning foundation (feedback storage). The unified types ensure Telegram and Slack adapters share a common interface.

Output: Extended DB schema with 3 new tables, unified channel type definitions, language detection utility, updated env config with Slack/Qdrant variables.
</objective>

<execution_context>
@C:/Users/dimsh/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/dimsh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-bot-shell-and-agent-brain/02-RESEARCH.md
@src/db/schema.ts
@src/config/env.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend database schema with messages, notification preferences, and user feedback tables</name>
  <files>src/db/schema.ts, src/config/env.ts</files>
  <action>
Extend `src/db/schema.ts` with three new tables:

1. **messages** table:
   - `id` bigserial primary key
   - `externalId` text not null (platform message ID: Telegram update_id or Slack ts)
   - `channelType` text not null ('telegram' | 'slack')
   - `channelId` text not null (Telegram chat_id or Slack channel ID)
   - `userId` text not null (sender user ID on the platform)
   - `role` text not null ('user' | 'assistant')
   - `text` text not null (message content)
   - `language` text ('ru' | 'en' | null)
   - `metadata` jsonb (optional platform-specific data)
   - `createdAt` timestamp with timezone, default now, not null
   - Indexes: `messages_channel_type_idx` on (channelType), `messages_channel_id_idx` on (channelId), `messages_created_at_idx` on (createdAt), composite `messages_channel_created_idx` on (channelId, createdAt)

2. **notificationPreferences** table:
   - `id` serial primary key
   - `userId` text not null (admin user identifier)
   - `category` text not null (e.g., 'task_deadline', 'email_urgent', 'calendar_meeting')
   - `urgencyLevel` text not null ('urgent' | 'important' | 'normal')
   - `deliveryChannel` text not null ('telegram' | 'slack')
   - `enabled` boolean default true
   - `createdAt` timestamp with timezone, default now
   - `updatedAt` timestamp with timezone, default now
   - Unique constraint on (userId, category)

3. **userFeedback** table (foundation for Phase 7 self-learning):
   - `id` bigserial primary key
   - `userId` text not null
   - `context` text not null (what the feedback is about)
   - `feedbackText` text not null (natural language feedback)
   - `category` text (auto-classified category, nullable)
   - `importanceScore` real (floating point -1.0 to 1.0, nullable)
   - `metadata` jsonb (optional structured data)
   - `createdAt` timestamp with timezone, default now, not null
   - Index: `user_feedback_created_at_idx` on (createdAt), `user_feedback_user_id_idx` on (userId)

Also extend `src/config/env.ts`:
- Add `SLACK_BOT_TOKEN` (z.string().optional()) - Slack bot token (xoxb-)
- Add `SLACK_APP_TOKEN` (z.string().optional()) - Slack app-level token (xapp-)
- Add `SLACK_ADMIN_USER_ID` (z.string().optional()) - Slack admin user ID
- Add `QDRANT_URL` (z.string().url().default('http://localhost:6333')) - Qdrant server URL

Make all Slack variables optional so the bot works without Slack configured.

Use the existing import style from drizzle-orm/pg-core. Follow the established pattern in schema.ts (pgTable, serial, text, timestamp, etc.). Add `boolean`, `real`, `bigserial` to imports if not already present.
  </action>
  <verify>
    <automated>npx tsc --noEmit</automated>
    <manual>Verify schema.ts exports messages, notificationPreferences, userFeedback tables</manual>
  </verify>
  <done>Three new tables defined in schema.ts with all columns and indexes. Env config accepts optional Slack tokens and Qdrant URL. TypeScript compiles cleanly.</done>
</task>

<task type="auto">
  <name>Task 2: Create unified channel types and language detection</name>
  <files>src/channels/types.ts, src/brain/language.ts</files>
  <action>
Create `src/channels/types.ts` with the following interfaces (export all):

```typescript
export interface InboundMessage {
  id: string                          // Unique message ID (platform-specific)
  channelType: 'telegram' | 'slack'
  channelId: string                   // Telegram chat ID or Slack channel ID
  userId: string                      // Sender user ID on the platform
  text: string                        // Message text content
  timestamp: Date
  replyToMessageId?: string           // If replying to a specific message
  metadata?: Record<string, unknown>  // Platform-specific extras
}

export interface OutboundMessage {
  channelType: 'telegram' | 'slack'
  channelId: string
  text: string
  replyToMessageId?: string           // For threading
  metadata?: Record<string, unknown>
}

export type MessageHandler = (message: InboundMessage) => Promise<void>

export interface ChannelAdapter {
  readonly channelType: 'telegram' | 'slack'
  start(): Promise<void>
  stop(): Promise<void>
  send(message: OutboundMessage): Promise<void>
  onMessage(handler: MessageHandler): void
}
```

Create `src/brain/language.ts`:

```typescript
const CYRILLIC_REGEX = /[\u0400-\u04FF]/g
const LATIN_REGEX = /[a-zA-Z]/g

export type Language = 'ru' | 'en'

export function detectLanguage(text: string): Language {
  const cyrillicCount = (text.match(CYRILLIC_REGEX) || []).length
  const latinCount = (text.match(LATIN_REGEX) || []).length
  return cyrillicCount > latinCount ? 'ru' : 'en'
}
```

This is a simple Cyrillic character heuristic per research recommendation. No external library needed for only Russian/English detection.

Use ESM imports with `.js` extensions per project convention.
  </action>
  <verify>
    <automated>npx tsc --noEmit</automated>
    <manual>Verify InboundMessage, OutboundMessage, ChannelAdapter are exported from types.ts; detectLanguage is exported from language.ts</manual>
  </verify>
  <done>Unified channel types defined with InboundMessage, OutboundMessage, and ChannelAdapter interfaces. Language detection correctly returns 'ru' for Cyrillic-heavy text and 'en' for Latin-heavy text. TypeScript compiles cleanly.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- `src/db/schema.ts` exports `messages`, `notificationPreferences`, `userFeedback` tables
- `src/channels/types.ts` exports `InboundMessage`, `OutboundMessage`, `ChannelAdapter`, `MessageHandler`
- `src/brain/language.ts` exports `detectLanguage` and `Language`
- `src/config/env.ts` accepts optional SLACK_BOT_TOKEN, SLACK_APP_TOKEN, SLACK_ADMIN_USER_ID, and QDRANT_URL
</verification>

<success_criteria>
- All three DB tables defined with correct columns, types, and indexes
- Unified message types ready for Telegram and Slack adapters to implement
- Language detection utility works for Russian and English
- Environment config extended with optional Slack and Qdrant variables
- TypeScript compiles cleanly with no errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-bot-shell-and-agent-brain/02-01-SUMMARY.md`
</output>
