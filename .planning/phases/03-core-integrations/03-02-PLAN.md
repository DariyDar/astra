---
phase: 03-core-integrations
plan: 02
type: execute
wave: 2
depends_on: [03-01]
files_modified:
  - src/integrations/monitors/clickup-deadlines.ts
  - src/bot/index.ts
autonomous: true
requirements: [CU-01]
user_setup: []

# NOTE: No scheduled LLM calls in this plan.
# ClickUp deadline monitor uses direct REST API calls (no Claude/LLM invocation).
# Calendar reminders and other LLM-based monitoring are deferred until
# trigger-based notification patterns are discussed and configured with the user.
# See: future phase for LLM usage audit and trigger-based optimization.

must_haves:
  truths:
    - "Bot checks ClickUp REST API for tasks with deadlines within 24h or overdue every 30 minutes"
    - "ClickUp deadline monitor does NOT call Claude or any LLM — it uses direct HTTP API calls only"
    - "Deadline notifications go through the existing NotificationDispatcher"
    - "Monitor only runs when ClickUp API credentials are configured"
    - "Bot starts without errors when ClickUp credentials are missing"
  artifacts:
    - path: "src/integrations/monitors/clickup-deadlines.ts"
      provides: "ClickUp deadline monitor: cron job checking for approaching/overdue tasks via REST API"
      exports: ["ClickUpDeadlineMonitor"]
  key_links:
    - from: "src/integrations/monitors/clickup-deadlines.ts"
      to: "src/notifications/dispatcher.ts"
      via: "dispatches NotificationItem with category task_deadline"
      pattern: "NotificationDispatcher"
    - from: "src/bot/index.ts"
      to: "src/integrations/monitors/clickup-deadlines.ts"
      via: "starts/stops monitor in bot lifecycle"
      pattern: "ClickUpDeadlineMonitor"
---

<objective>
Build ClickUp deadline monitor that alerts about tasks approaching deadline (within 24h) or overdue using direct REST API calls (no LLM). Uses the existing NotificationDispatcher.

Purpose: Proactive alerts about deadlines are a key PM workflow value — the bot watches for problems without waiting to be asked.
Output: One monitor module (ClickUp deadlines via REST API) + bot integration wiring.

NOTE: Calendar reminders and other LLM-based proactive features are deferred until trigger-based notification patterns are discussed and configured with the user. No scheduled LLM calls.
</objective>

<execution_context>
@C:/Users/dimsh/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/dimsh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-core-integrations/03-RESEARCH.md
@.planning/phases/03-core-integrations/03-01-SUMMARY.md

# Key existing files
@src/config/env.ts
@src/notifications/dispatcher.ts
@src/notifications/urgency.ts
@src/notifications/digest.ts
@src/bot/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: ClickUp deadline monitor (direct REST API, no LLM)</name>
  <files>
    src/integrations/monitors/clickup-deadlines.ts
  </files>
  <action>
1. **Create `src/integrations/monitors/clickup-deadlines.ts`**: Export a `ClickUpDeadlineMonitor` class.

   Constructor takes: `{ apiKey: string, teamId: string, dispatcher: NotificationDispatcher, adminUserId: string }`

   The class has:
   - `start()`: Starts a `node-cron` job running every 30 minutes (`*/30 * * * *`). Also runs an immediate check on start.
   - `stop()`: Stops the cron job.
   - `private async checkDeadlines()`: The core logic:
     a. Call ClickUp REST API: `GET https://api.clickup.com/api/v2/team/${teamId}/task` with query params:
        - `due_date_gt`: now minus 7 days (catch overdue tasks)
        - `due_date_lt`: now plus 24 hours (catch approaching tasks)
        - `statuses[]=open&statuses[]=in progress`
        - `include_closed=false`
     b. Parse response as `{ tasks: ClickUpTask[] }` where ClickUpTask has: `id, name, due_date (string|null), status: { status: string }, assignees: Array<{ username: string }>, url: string, list: { name: string }`
     c. Filter tasks where `due_date` is not null
     d. Categorize: overdue (due_date < now) and approaching (due_date within 24h)
     e. Track already-notified task IDs in a `Set<string>` to avoid duplicate alerts within a session (reset on bot restart is fine)
     f. For each new task, dispatch via `NotificationDispatcher.dispatch()`:
        - `userId`: `adminUserId`
        - `category`: `'task_deadline'`
        - `title`: "Overdue: {task.name}" or "Due soon: {task.name}"
        - `body`: "List: {task.list.name} | Status: {task.status.status} | Due: {formatted_date} | {task.url}"
        - `urgency`: overdue = 'urgent', approaching = 'important'
     g. Use native `fetch` for HTTP calls (Node.js 18+). Headers: `{ Authorization: apiKey }`.
     h. Wrap in try/catch. Log errors with pino logger. Never throw -- monitor failures must not crash the bot.

   IMPORTANT: This monitor uses ONLY direct REST API calls. No Claude/LLM invocation whatsoever.
  </action>
  <verify>
    <automated>npx tsc --noEmit 2>&1 | head -20</automated>
    <manual>Review clickup-deadlines.ts for correct API usage and error handling. Confirm NO LLM/Claude calls.</manual>
  </verify>
  <done>
    - clickup-deadlines.ts exports ClickUpDeadlineMonitor with start/stop/checkDeadlines
    - Uses direct ClickUp REST API (no LLM calls)
    - Uses existing NotificationDispatcher for delivery
    - Has deduplication to prevent repeated alerts
    - Handles errors gracefully (log + continue)
    - TypeScript compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire ClickUp monitor into bot entry point</name>
  <files>
    src/bot/index.ts
  </files>
  <action>
1. **Update `src/bot/index.ts`**: Add conditional ClickUp monitor creation and lifecycle management.

   After the existing DigestScheduler setup:

   a. Import `ClickUpDeadlineMonitor` from `../integrations/monitors/clickup-deadlines.js`
   b. Conditionally create ClickUp monitor:
      ```typescript
      let clickUpMonitor: ClickUpDeadlineMonitor | undefined
      if (env.CLICKUP_API_KEY && env.CLICKUP_TEAM_ID) {
        clickUpMonitor = new ClickUpDeadlineMonitor({
          apiKey: env.CLICKUP_API_KEY,
          teamId: env.CLICKUP_TEAM_ID,
          dispatcher,  // existing NotificationDispatcher instance
          adminUserId: env.TELEGRAM_ADMIN_CHAT_ID,
        })
        clickUpMonitor.start()
        logger.info('ClickUp deadline monitor started')
      } else {
        logger.info('ClickUp credentials not configured, deadline monitor disabled')
      }
      ```
   c. Add to graceful shutdown:
      ```typescript
      clickUpMonitor?.stop()
      ```

2. **Verify the existing graceful shutdown pattern** in bot/index.ts handles the new monitor. The monitor's `stop()` method should be called alongside existing cleanup (digest cron stop, router stop, etc.).

   NOTE: No CalendarReminderMonitor — calendar and other LLM-based proactive monitoring will be added after trigger-based notification patterns are discussed with the user.
  </action>
  <verify>
    <automated>npx tsc --noEmit 2>&1 | head -20</automated>
    <manual>Review bot/index.ts for correct conditional creation and shutdown order</manual>
  </verify>
  <done>
    - ClickUp monitor created and started only when CLICKUP_API_KEY and CLICKUP_TEAM_ID are set
    - Monitor stopped in graceful shutdown
    - Bot starts without errors when ClickUp env vars are missing
    - NO scheduled LLM/Claude calls present anywhere
    - TypeScript compiles without errors
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. Bot starts without errors when CLICKUP_API_KEY is not set
3. When CLICKUP_API_KEY and CLICKUP_TEAM_ID are set, monitor logs its start message
4. Grep codebase confirms NO scheduled Claude/LLM calls (no callClaude in cron/monitor code)
</verification>

<success_criteria>
- ClickUp deadline monitor checks every 30 minutes via direct REST API, dispatches notifications for overdue and approaching tasks
- Monitor is opt-in (only starts when credentials configured)
- Integrates with existing NotificationDispatcher
- Graceful shutdown stops the monitor
- ZERO scheduled LLM calls — all LLM usage is user-initiated only
</success_criteria>

<output>
After completion, create `.planning/phases/03-core-integrations/03-02-SUMMARY.md`
</output>
